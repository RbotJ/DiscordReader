Here are a few areas you can tighten up to leverage the latest alpaca-py patterns, simplify your logic, and decouple responsibilities:

1. Swap out your custom order wrappers for typed OrderRequest classes
Rather than calling your own submit_market_order / submit_limit_order, build and submit MarketOrderRequest and LimitOrderRequest objects directly against trading_client.submit_order(...). This gives you strong typing, built-in validation, and access to all order-type options (e.g. stop, trailing stop, bracket legs) 
Alpaca
Alpaca
.

python
Copy
Edit
from alpaca.trading.requests import MarketOrderRequest, LimitOrderRequest
from alpaca.trading.enums    import OrderSide, TimeInForce

def _execute_trade(
    self, symbol: str, qty: int, side: str, entry_price: float, stop_price: float
) -> Dict:
    # 1️⃣ Market entry
    mkt_req = MarketOrderRequest(
        symbol=symbol,
        qty=qty,
        side=OrderSide.BUY if side=="buy" else OrderSide.SELL,
        time_in_force=TimeInForce.DAY,
    )
    entry_order = trading_client.submit_order(order_data=mkt_req)

    # 2️⃣ Stop-loss leg (if desired)
    if stop_price > 0:
        stop_req = LimitOrderRequest(
            symbol=symbol,
            qty=qty,
            side=OrderSide.SELL if side=="buy" else OrderSide.BUY,
            time_in_force=TimeInForce.GTC,
            limit_price=stop_price,
        )
        stop_order = trading_client.submit_order(order_data=stop_req)
    ```

---

### 2. Refresh account data on each signal, don’t cache at init  
By calling `get_account_info()` inside `process_new_signal`, you avoid stale equity/buying-power calculations. Equity can shift intra-day, so recalc position size against fresh data each time.

```python
def process_new_signal(…):
    # …
    account = get_account_info()
    self.account_info = account  # refresh
    # then compute sizing…
3. Extract trigger parsing into a helper
Your _determine_trade_direction does a lot of type checks on signal.trigger. Hide that complexity behind a small utility:

python
Copy
Edit
def _parse_trigger(trigger_raw) -> float:
    """Normalize trigger formats to a single float value or 0."""
    # handle dict / list / str / numeric uniformly…
    return …  # single float or 0

# then simply:
trigger_value = _parse_trigger(signal.trigger)
This makes the main logic far easier to read and maintain.

4. Separate execution, sizing, and persistence into layers
Execution: all alpaca calls

Sizing: risk calculations, fetching quotes

Persistence: DB updates

By isolating each concern into its own class or module, you can unit-test them independently and swap out implementations easily.

5. Use Alpaca’s clock API for any scheduling
You’re already calling trading_client.get_clock(), which is great. If you find thread-management cumbersome, consider a scheduler library (e.g. APScheduler) that can fire a job at clock.next_close - 5min.

6. Clean up your SQLAlchemy session usage
Right now you commit inside _record_signal_execution. To handle failures more robustly, you might:

Open a new session for writes

Wrap in a transaction context manager

Record both the entry and stop order IDs

This ensures DB state always mirrors your actual executions.

By adopting these patterns, you’ll be fully aligned with alpaca-py’s best practices, reduce boilerplate, and make each component more testable and readable.