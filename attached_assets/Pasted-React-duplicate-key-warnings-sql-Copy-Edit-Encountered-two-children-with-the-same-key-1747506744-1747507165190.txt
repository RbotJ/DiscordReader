React “duplicate key” warnings
sql
Copy
Edit
Encountered two children with the same key, `1747506744320`
Keys should be unique so that components maintain their identity across updates…
Context:
React uses the key prop on list items to track which item is which between renders. If two siblings share the same key, React can’t tell them apart and may drop or duplicate items.

Why it happens:
You’re probably doing something like:

jsx
Copy
Edit
{signals.map(s => <SignalRow key={s.timestamp} data={s} />)}
If two signals fire within the same millisecond (same timestamp), they collide.

Fixes:

Use a truly unique key. Combine multiple fields:

jsx
Copy
Edit
<SignalRow key={`${s.ticker}-${s.type}-${s.timestamp}`} …/>
Fallback to array index only if the list is static (not reordered/filtered):

jsx
Copy
Edit
{signals.map((s,i) => <SignalRow key={i} …/>)}
Generate a UUID (e.g. via crypto.randomUUID()) when you persist the signals, and use that as the key.

2. “Objects are not valid as a React child”
pgsql
Copy
Edit
Objects are not valid as a React child (found: object with keys {})…
Context:
React can only render primitives (strings, numbers), React elements or arrays thereof. Passing a plain object into JSX will throw.

Common culprits:

jsx
Copy
Edit
<div>{response}</div>         // if response is an object
<p>{JSON.parse(jsonBlob)}</p> // if you forgot to pick a property
Fixes:

Stringify before rendering:

jsx
Copy
Edit
<pre>{JSON.stringify(response, null, 2)}</pre>
Access specific fields:

jsx
Copy
Edit
<span>{account.balance}</span>
Map arrays of objects into components:

jsx
Copy
Edit
{positions.map(pos =>
  <PositionRow key={pos.id} pos={pos}/>
)}
3. DOM null-refs (“Cannot set properties of null…” / “Cannot read properties of null…”)
pgsql
Copy
Edit
Cannot set properties of null (setting 'textContent')
Cannot read properties of null (reading 'classList')
Context:
These come from vanilla-JS code like:

js
Copy
Edit
document.getElementById('posCount').textContent = data.length;
When the selector doesn’t find an element (maybe due to a typo or running before the DOM is ready), it returns null.

Fixes:

Wrap DOM code in a ready check:

js
Copy
Edit
document.addEventListener('DOMContentLoaded', () => {
  const el = document.getElementById('posCount');
  if (el) el.textContent = data.length;
});
Prefer React state + JSX instead of manual DOM mutations:

jsx
Copy
Edit
function PositionCount({ positions }) {
  return <div id="posCount">{positions.length}</div>;
}
Guard every access:

js
Copy
Edit
const el = document.querySelector('.status');
if (el) el.classList.add('online');
4. API fetch errors (TypeError {})
javascript
Copy
Edit
Error fetching positions:
TypeError {}
Context:
A bare TypeError {} usually means your .catch() is catching something with no .message (e.g. a thrown object, or a network failure).

Troubleshooting steps:

Log more detail:

js
Copy
Edit
fetch('/api/positions')
  .then(res => {
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  })
  .then(setPositions)
  .catch(err => {
    console.error('fetch positions failed:', err, err.message, err.stack);
  });
Inspect network tab in DevTools:

Are you hitting the right URL?

Is CORS blocking the request?

Does the server respond with JSON or an HTML error page?

Verify your backend:

Ensure the endpoint is up.

Return proper JSON and status codes.

5. WebSocket connection errors
nginx
Copy
Edit
WebSocket connection error:
Error {}
Context:
This indicates the client failed to open/maintain the WS connection. Could be:

Wrong URL (ws:// vs wss://).

Server not running or blocked by CORS/firewall.

Heartbeat/ping not implemented, so server drops idle connections.

Improvement ideas:

Validate URL:

js
Copy
Edit
const ws = new WebSocket('wss://your-domain.com/updates');
Add event handlers:

js
Copy
Edit
ws.onopen    = () => console.log('WS open');
ws.onerror   = e => console.error('WS error', e);
ws.onclose   = e => {
  console.warn('WS closed, retrying in 3s', e);
  setTimeout(connectWebSocket, 3000);
};
ws.onmessage = msg => handleUpdate(JSON.parse(msg.data));
Implement ping/pong on both client & server to keep the socket alive.

Fall back to HTTP polling if WS is down.

Putting it all together—sample React-centric approach
Centralize data fetching & WS in a custom hook:

tsx
Copy
Edit
function useStrategyData() {
  const [positions, setPositions] = useState([]);
  const [wsError, setWsError] = useState<string|null>(null);
  useEffect(() => {
    fetch('/api/positions')…;
    const ws = new WebSocket('wss://…');
    ws.onerror = e => setWsError('WebSocket disconnected');
    …
    return () => ws.close();
  }, []);
  return { positions, wsError };
}
Render lists with stable unique keys:

tsx
Copy
Edit
function PositionsTable({ positions }) {
  return (
    <table>
      <tbody>
        {positions.map(pos =>
          <tr key={pos.id}>
            <td>{pos.ticker}</td>
            <td>{pos.qty}</td>
          </tr>
        )}
      </tbody>
    </table>
  );
}
Avoid direct DOM manipulation; let React own the UI:

tsx
Copy
Edit
function Dashboard() {
  const { positions, wsError } = useStrategyData();
  if (wsError) return <Alert>{wsError}</Alert>;
  return <PositionsTable positions={positions}/>;
}
By grouping your error handling into React hooks/components, ensuring keys are unique, never rendering raw objects, and gracefully handling network/WS failures, you’ll eliminate these runtime errors and make your dashboard far more robust.