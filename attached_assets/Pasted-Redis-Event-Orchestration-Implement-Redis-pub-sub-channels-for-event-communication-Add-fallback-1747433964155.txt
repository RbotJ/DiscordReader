Redis Event Orchestration:

Implement Redis pub/sub channels for event communication
Add fallback mechanism for environments without Redis
Define event schemas for main event types
Implementation Proposal for Phase 2
Based on your phased build roadmap, here are the implementation details for the next components:

1. Market Feed & Detection (Phase 2)
features/market/price_monitor.py:

Connect to Alpaca WebSocket API for real-time price data
Implement symbol watchlist management
Create price listener and event publisher
# features/market/price_monitor.py
import asyncio
import json
import logging
from datetime import datetime
from alpaca.data.live import StockDataStream
from common.redis_utils import get_redis_client
logger = logging.getLogger(__name__)
PRICE_UPDATE_CHANNEL = "market.price_update"
class PriceMonitor:
    def __init__(self, api_key, api_secret):
        self.watchlist = set()
        self.stock_stream = StockDataStream(api_key, api_secret)
        self.redis = get_redis_client()
        self.running = False
        
    async def start(self):
        """Start the price monitor."""
        self.running = True
        self.stock_stream.subscribe_trades(self._process_trade, *self.watchlist)
        await self.stock_stream.run()
    
    def stop(self):
        """Stop the price monitor."""
        self.running = False
        self.stock_stream.stop()
    
    def _process_trade(self, trade):
        """Process a trade update from Alpaca."""
        symbol = trade.symbol
        price = trade.price
        timestamp = trade.timestamp
        
        logger.debug(f"Trade update: {symbol} @ {price} ({timestamp})")
        
        # Publish to Redis
        if self.redis:
            event = {
                "symbol": symbol,
                "price": price,
                "timestamp": timestamp.isoformat()
            }
            self.redis.publish(PRICE_UPDATE_CHANNEL, json.dumps(event))
        
        # Also add direct trigger checking here for environments without Redis
        self._check_triggers(symbol, price)
    
    def _check_triggers(self, symbol, price):
        """Check if the current price triggers any monitored conditions."""
        # Implementation will interact with the strategy/detector module
        pass
        
    def add_symbol(self, symbol):
        """Add a symbol to the watchlist."""
        symbol = symbol.upper()
        if symbol not in self.watchlist:
            self.watchlist.add(symbol)
            if self.running:
                # Resubscribe with updated watchlist
                self.stock_stream.subscribe_trades(self._process_trade, *self.watchlist)
            logger.info(f"Added {symbol} to watchlist")
features/market/historical_data.py:

Fetch historical candle data for analysis
Support different timeframes (1m, 5m, 10m, 15m, 30m, 1h, 1d)
# features/market/historical_data.py
import logging
from datetime import datetime, timedelta
from alpaca.data.historical import StockHistoricalDataClient
from alpaca.data.requests import StockBarsRequest
from alpaca.data.timeframe import TimeFrame
logger = logging.getLogger(__name__)
class HistoricalDataProvider:
    def __init__(self, api_key, api_secret):
        self.client = StockHistoricalDataClient(api_key, api_secret)
        
    def get_candles(self, symbol, timeframe, start, end=None):
        """
        Get historical candle data for a symbol.
        
        Args:
            symbol: The ticker symbol
            timeframe: One of "1m", "5m", "10m", "15m", "30m", "1h", "1d"
            start: Start datetime
            end: End datetime (defaults to now)
            
        Returns:
            List of candle data (OHLCV)
        """
        # Convert timeframe string to TimeFrame enum
        if timeframe == "1m":
            tf = TimeFrame.Minute
        elif timeframe == "5m":
            tf = TimeFrame.Minute
            multiplier = 5
        elif timeframe == "10m":
            tf = TimeFrame.Minute
            multiplier = 10
        elif timeframe == "15m":
            tf = TimeFrame.Minute
            multiplier = 15
        elif timeframe == "30m":
            tf = TimeFrame.Minute
            multiplier = 30
        elif timeframe == "1h":
            tf = TimeFrame.Hour
        elif timeframe == "1d":
            tf = TimeFrame.Day
        else:
            raise ValueError(f"Unsupported timeframe: {timeframe}")
        
        # Default end time is now
        if not end:
            end = datetime.now()
        
        # Create request
        request_params = StockBarsRequest(
            symbol_or_symbols=symbol,
            timeframe=tf,
            start=start,
            end=end
        )
        
        try:
            bars = self.client.get_stock_bars(request_params)
            # Convert to list of dictionaries for easier consumption
            return self._format_bars(bars.data[symbol])
        except Exception as e:
            logger.error(f"Error fetching historical data for {symbol}: {e}")
            return []
    
    def _format_bars(self, bars):
        """Format bar data for API response."""
        return [
            {
                "timestamp": bar.timestamp.isoformat(),
                "open": bar.open,
                "high": bar.high,
                "low": bar.low,
                "close": bar.close,
                "volume": bar.volume
            }
            for bar in bars
        ]